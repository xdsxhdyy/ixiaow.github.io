---
layout: post
title:  "mysql 自增id和UUID做主键性能分析，及最优方案"
date:   2018-01-07
desc: "mysql 自增id和UUID做主键性能分析，及最优方案"
keywords: "mysql,主键类型"
categories: [Sql]
tags: [sql, mysql, 主键类型]
---


# mysql 自增id和UUID做主键性能分析，及最优方案

##1.为什么要使用uuid做主键
(1).其实在innodb存储引擎下，自增长的id做主键性能已经达到了最佳。不论是存储和读取速度都是最快的，而且占的存储空间也是最小。

(2).但是在我们实际到项目中会碰到问题，历史数据表的主键id会与数据表的id重复，两张自增id做主键的表合并时，id一定会有冲突，但如果各自的id还关联了其他表，这就很不好操作。

(3).如果使用UUID，生成的ID不仅是表独立的，而且是库独立的。对以后的数据操作很有好处，可以说一劳永逸。



##2.UUID优缺点
缺点： 1.  影响插入速度， 并且造成硬盘使用率低
      2.  uuid之间比较大小相对数字慢不少， 影响查询速度。
      3.  uuid占空间大， 如果你建的索引越多， 影响越严重

优点：出现数据拆分、合并存储的时候，能达到全局的唯一性



##3.最优方案
(1).InnoDB引擎表是基于B+树的索引组织表。

(2).B+树：B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按**键值的大小顺序**存放在同一层的叶节点中，各叶节点指针进行连接。


(3).InnoDB主索引：叶节点包含了完整的数据记录。这种索引叫做聚集索引。InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引

(4).聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

**综合上述可得：**

**(1).**如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。**为了存储和查询性能应该使用自增长id做主键。**

**(2).**对于InnoDB的主索引，数据会按照主键进行排序，由于UUID的无序性，InnoDB会产生巨大的IO压力，此时不适合使用UUID做物理主键，可以把它作为逻辑主键，物理主键依然使用自增ID。**为了全局的唯一性，应该用uuid做索引关联其他表或做外键。**



##4.如果非要使用uuid做主键，下面是小建议：
如果是主从即M-S模式，最好是不使用mysql自带函数uuid来生成唯一主键，因为主表生成的uuid要再关联从表时，需要再去数据库查出这个uuid，需要多进行一次数据库交互，而且在这个时间差里面主表很有可能还有数据生成，这样就很容易导致关联的uuid出错。如果真要使用uuid，可以在Java中生成后，直接存储到DB里，这时主从的uuid就是一样的了！


