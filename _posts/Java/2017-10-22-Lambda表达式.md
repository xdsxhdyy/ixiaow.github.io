---
layout: post
title:  "Lambda表达式"
date:   2017-10-22
desc: "Java Lambda表达式"
keywords: "java,Lambda表达式"
categories: [Java]
tags: [java, lambda]
---

### lambad表达式（又被称为闭包或匿名方法）

#### 匿名类内部类的劣势：

* 语法过于冗余
* 匿名类中的 this 和变量名容易使人产生误解
* 类型载入和实例创建语义不够灵活
* 无法捕获非 final 的局部变量
* 无法对控制流进行抽象
    
* 尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：

    * 接口是 Java 类型系统的一部分
    * 接口天然就拥有其运行时表示（Runtime representation）
    * 接口可以通过 Javadoc 注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）
    
    
* 函数式接口（Functional interfaces）

    * 大多数回调接口都拥有这个特征：比如 Runnable 接口和 Comparator 接口。我们把这些只拥有一个方法的接口称为 函数式接口。（之前它们被称为 SAM类型，即 单抽象方法类型（Single Abstract Method））
    
* lambda表达式

    * 匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面ActionListener的例子里的五行代码中仅有一行在做实际工作。

    * lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。
    
    * 语法（参数列表、箭头符号-> 和函数体组成，函数体既可以是一个表达式也可以是一个语句块）
    
        * 表达式：表达式会被执行，然后返回执行结果
        * 语句块：语句块中的语句会被依次执行，就像方法中的一样
            * return 会把控制权交给匿名调用者
            * continue和break只能在循环中使用
            
* 目标类型

    * 需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。

    * 编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导，这个被期待的类型被称为目标类型.lambda表达式只能出现在目标类型为函数式接口的上下文中。

    * 当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型T：

        * T是一个函数式接口
        
        * lambda表达式的参数和T的方法参数在数量和类型上一一对应
        
        * lambda表达式的返回值和T的方法返回值相兼容（Compatible）
        * lambda表达式内所抛出的异常和T的方法throws类型相兼容
    
    * 此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：